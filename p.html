<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Penis Anatomy</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #controls button, #controls select, #controls input {
            padding: 8px 12px;
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover, #controls select:hover {
            background-color: #666;
        }
        #controls label {
            margin-bottom: -5px;
            font-size: 12px;
            color: #ccc;
        }
        #infoBox {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            font-size: 14px;
        }
        #infoBox h3 { margin-top: 0; color: #0af; }
        .highlight-btn { background-color: #0af !important; color: #111 !important; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <label for="shape-select">Change Shape:</label>
        <select id="shape-select">
            <option value="penis">Penis</option>
            <option value="sphere">Sphere</option>
            <option value="cube">Cube</option>
            <option value="torus">Torus</option>
        </select>

        <label for="color-mode-select">Color Mode:</label>
        <select id="color-mode-select">
            <option value="anatomical">Anatomical</option>
            <option value="random">Random</option>
            <option value="solid">Solid</option>
            <option value="positional">Positional</option>
        </select>
        <input type="color" id="solid-color-picker" value="#00ffff" style="display:none;">

        <label for="particle-size-slider">Particle Size:</label>
        <input type="range" id="particle-size-slider" min="0.5" max="5" step="0.1" value="1.5">

        <label>Highlight Anatomy:</label>
        <button id="btn-glans">Glans</button>
        <button id="btn-shaft">Shaft (Corpora)</button>
        <button id="btn-urethra">Urethra (Path)</button>
        <button id="btn-reset-highlight">Reset Highlight</button>
    </div>

    <div id="infoBox">
        <h3>Penis Anatomy Visualizer</h3>
        <p>Interact with the controls to change the particle cloud's shape and appearance. Click the "Highlight Anatomy" buttons to learn about different parts.</p>
        <div id="anatomy-info"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, particles, controls;
        let particleMaterial;
        const numParticles = 20000;
        const particlePositions = new Float32Array(numParticles * 3);
        const particleColors = new Float32Array(numParticles * 3);
        const particleAlphas = new Float32Array(numParticles);
        const particleBaseSizes = new Float32Array(numParticles);

        // To store original positions for morphing and anatomical regions
        const targetPositions = {};
        let currentShape = 'penis';
        let currentColorMode = 'anatomical';
        let currentSolidColor = new THREE.Color(0x00ffff);

        // Anatomical part definitions (particle indices)
        const anatomyParts = {
            glans: [],
            shaft: [],
            urethra: [] // Will be a subset of shaft/glans particles
        };
        const anatomyInfoContent = {
            glans: "<h3>Glans (Head)</h3><p>The sensitive, rounded tip of the penis. It contains a high concentration of nerve endings and the opening of the urethra (meatus).</p>",
            shaft: "<h3>Shaft (Corpora)</h3><p>The main body of the penis. Contains erectile tissues: two Corpora Cavernosa (main erectile bodies) and one Corpus Spongiosum (surrounds the urethra and forms the glans).</p>",
            urethra: "<h3>Urethra (Path)</h3><p>A tube that runs through the Corpus Spongiosum, from the bladder to the meatus at the tip of the glans. It carries both urine and semen.</p>",
            default: "<h3>Penis Anatomy Visualizer</h3><p>Interact with the controls to change the particle cloud's shape and appearance. Click the 'Highlight Anatomy' buttons to learn about different parts.</p>"
        };

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 10, 10);
            scene.add(pointLight);

            // Particle Geometry and Material
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            // geometry.setAttribute('alpha', new THREE.BufferAttribute(particleAlphas, 1)); // For individual alpha
            // geometry.setAttribute('size', new THREE.BufferAttribute(particleBaseSizes, 1)); // For individual size if shader material

            particleMaterial = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending, // Brighter where particles overlap
                depthWrite: false // Helps with transparency sorting issues
            });

            particles = new THREE.Points(geometry, particleMaterial);
            scene.add(particles);

            // Generate initial particle positions for all shapes
            generateShapePositions();
            morphToShape(currentShape, true); // Initial morph without animation
            updateColors();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('shape-select').addEventListener('change', (e) => morphToShape(e.target.value));
            document.getElementById('color-mode-select').addEventListener('change', (e) => {
                currentColorMode = e.target.value;
                document.getElementById('solid-color-picker').style.display = (currentColorMode === 'solid') ? 'block' : 'none';
                updateColors();
            });
            document.getElementById('solid-color-picker').addEventListener('input', (e) => {
                currentSolidColor.set(e.target.value);
                if (currentColorMode === 'solid') updateColors();
            });
            document.getElementById('particle-size-slider').addEventListener('input', (e) => {
                particleMaterial.size = parseFloat(e.target.value);
            });

            document.getElementById('btn-glans').addEventListener('click', () => highlightAnatomy('glans'));
            document.getElementById('btn-shaft').addEventListener('click', () => highlightAnatomy('shaft'));
            document.getElementById('btn-urethra').addEventListener('click', () => highlightAnatomy('urethra'));
            document.getElementById('btn-reset-highlight').addEventListener('click', () => {
                highlightAnatomy(null);
                updateColors(); // Reapply current color mode
            });
            
            updateInfoBox('default');
        }

        function generateShapePositions() {
            targetPositions.sphere = generateSpherePositions(5);
            targetPositions.cube = generateCubePositions(8);
            targetPositions.torus = generateTorusPositions(4, 1.5);
            targetPositions.penis = generatePenisPositions();
        }

        function generateSpherePositions(radius) {
            const positions = new Float32Array(numParticles * 3);
            for (let i = 0; i < numParticles; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = radius * Math.cbrt(Math.random()); // Distribute points evenly within sphere volume
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
            }
            return positions;
        }

        function generateCubePositions(size) {
            const positions = new Float32Array(numParticles * 3);
            const halfSize = size / 2;
            for (let i = 0; i < numParticles; i++) {
                positions[i * 3] = (Math.random() - 0.5) * size;
                positions[i * 3 + 1] = (Math.random() - 0.5) * size;
                positions[i * 3 + 2] = (Math.random() - 0.5) * size;
            }
            return positions;
        }

        function generateTorusPositions(radius, tube) {
            const positions = new Float32Array(numParticles * 3);
            for (let i = 0; i < numParticles; i++) {
                const theta = Math.random() * 2 * Math.PI; // Angle around the main circle
                const phi = Math.random() * 2 * Math.PI;   // Angle around the tube's cross-section
                
                // To distribute points more evenly within the torus volume,
                // we can vary the distance from the center of the tube
                const rTube = tube * Math.sqrt(Math.random()); 

                positions[i * 3] = (radius + rTube * Math.cos(phi)) * Math.cos(theta);
                positions[i * 3 + 1] = (radius + rTube * Math.cos(phi)) * Math.sin(theta);
                positions[i * 3 + 2] = rTube * Math.sin(phi);
            }
            return positions;
        }
        
        function generatePenisPositions() {
            const positions = new Float32Array(numParticles * 3);
            anatomyParts.glans = [];
            anatomyParts.shaft = [];
            anatomyParts.urethra = [];

            const shaftLength = 8;
            const shaftRadius = 1.2;
            const glansRadius = 1.5;
            const glansLength = 2.5; // How much it extends beyond the shaft

            const numShaftParticles = Math.floor(numParticles * 0.7);
            const numGlansParticles = numParticles - numShaftParticles;

            // Shaft (Corpora Cavernosa and Spongiosum)
            for (let i = 0; i < numShaftParticles; i++) {
                const r = shaftRadius * Math.sqrt(Math.random()); // Distribute within circle
                const theta = Math.random() * 2 * Math.PI;
                const z = (Math.random() - 0.5) * shaftLength; // Centered around origin

                positions[i * 3] = r * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(theta);
                positions[i * 3 + 2] = z;
                anatomyParts.shaft.push(i);

                // Simple Urethra path (central core)
                if (r < shaftRadius * 0.3) { // Particles in the central 30% of radius
                    anatomyParts.urethra.push(i);
                }
            }

            // Glans
            const glansBaseZ = shaftLength / 2;
            for (let i = 0; i < numGlansParticles; i++) {
                const particleIndex = numShaftParticles + i;
                // Make it somewhat bulbous, tapering from base to tip
                const u = Math.random(); // For distributing along length
                const v = Math.random(); // For distributing radially

                const currentZRelative = u * glansLength; // 0 to glansLength
                // Radius decreases from glansRadius at base to 0 at tip (parabolic for smoother tip)
                const currentRadius = glansRadius * (1 - Math.pow(currentZRelative / glansLength, 2));
                
                const r = currentRadius * Math.sqrt(v); // Distribute within circle
                const theta = Math.random() * 2 * Math.PI;

                positions[particleIndex * 3] = r * Math.cos(theta);
                positions[particleIndex * 3 + 1] = r * Math.sin(theta);
                positions[particleIndex * 3 + 2] = glansBaseZ + currentZRelative;
                anatomyParts.glans.push(particleIndex);
                
                // Urethra path continues into glans
                if (r < glansRadius * 0.2) { // Smaller core in glans
                     anatomyParts.urethra.push(particleIndex);
                }
            }
            return positions;
        }


        function morphToShape(shapeName, immediate = false) {
            if (!targetPositions[shapeName]) {
                console.warn(`Shape ${shapeName} not defined.`);
                return;
            }
            currentShape = shapeName;
            const newPositions = targetPositions[shapeName];
            const positionAttribute = particles.geometry.attributes.position;

            if (immediate) {
                for (let i = 0; i < numParticles; i++) {
                    positionAttribute.setXYZ(i, newPositions[i * 3], newPositions[i * 3 + 1], newPositions[i * 3 + 2]);
                }
                positionAttribute.needsUpdate = true;
                updateColors(); // Update colors based on new shape if needed
            } else {
                // Anime.js for smooth transition
                // Create a temporary object for Anime.js to tween
                const targets = [];
                for (let i = 0; i < numParticles; i++) {
                    targets.push({
                        x: positionAttribute.getX(i),
                        y: positionAttribute.getY(i),
                        z: positionAttribute.getZ(i)
                    });
                }

                anime({
                    targets: targets,
                    x: (p, i) => newPositions[i * 3],
                    y: (p, i) => newPositions[i * 3 + 1],
                    z: (p, i) => newPositions[i * 3 + 2],
                    duration: 1500,
                    easing: 'easeInOutExpo',
                    update: function() {
                        for (let i = 0; i < numParticles; i++) {
                            positionAttribute.setXYZ(i, targets[i].x, targets[i].y, targets[i].z);
                        }
                        positionAttribute.needsUpdate = true;
                    },
                    complete: function() {
                        updateColors(); // Update colors once morphing is complete
                    }
                });
            }
             // Reset any highlights when shape changes
            highlightAnatomy(null);
            updateInfoBox('default');
            if (shapeName !== 'penis') {
                document.getElementById('btn-glans').disabled = true;
                document.getElementById('btn-shaft').disabled = true;
                document.getElementById('btn-urethra').disabled = true;
            } else {
                document.getElementById('btn-glans').disabled = false;
                document.getElementById('btn-shaft').disabled = false;
                document.getElementById('btn-urethra').disabled = false;
            }
        }

        function updateColors(highlightPart = null, highlightColor = new THREE.Color(0xffff00)) {
            const colorAttribute = particles.geometry.attributes.color;
            const positionAttribute = particles.geometry.attributes.position;
            const baseColor = new THREE.Color();

            for (let i = 0; i < numParticles; i++) {
                let R, G, B;

                if (highlightPart) {
                    if (anatomyParts[highlightPart] && anatomyParts[highlightPart].includes(i)) {
                        baseColor.set(highlightColor);
                    } else {
                        baseColor.set(0x333333); // Dim unhighlighted parts
                    }
                } else {
                    switch (currentColorMode) {
                        case 'anatomical':
                            if (currentShape === 'penis') {
                                if (anatomyParts.glans.includes(i)) {
                                    baseColor.setHSL(0.0, 0.8, 0.6); // Pink/Reddish for glans
                                } else if (anatomyParts.shaft.includes(i)) {
                                    baseColor.setHSL(0.05, 0.7, 0.5); // Slightly different for shaft
                                } else {
                                    baseColor.setHSL(Math.random(), 0.7, 0.5); // Fallback
                                }
                                 // Urethra particles can be subtly different if desired, but keep it simple for now
                                if (anatomyParts.urethra.includes(i)) {
                                     baseColor.lerp(new THREE.Color(0x87CEEB), 0.3); // Slightly bluer tint for urethra
                                }

                            } else {
                                baseColor.setHSL(Math.random(), 0.7, 0.5); // Random for other shapes
                            }
                            break;
                        case 'random':
                            baseColor.setHSL(Math.random(), 0.7, 0.5);
                            break;
                        case 'solid':
                            baseColor.set(currentSolidColor);
                            break;
                        case 'positional':
                            const x = positionAttribute.getX(i);
                            const y = positionAttribute.getY(i);
                            const z = positionAttribute.getZ(i);
                            // Normalize positions roughly (assuming shape extent is ~10)
                            R = Math.abs(x / 10);
                            G = Math.abs(y / 10);
                            B = Math.abs(z / 10);
                            baseColor.setRGB(R, G, B);
                            break;
                    }
                }
                colorAttribute.setXYZ(i, baseColor.r, baseColor.g, baseColor.b);
            }
            colorAttribute.needsUpdate = true;
        }

        function highlightAnatomy(partName) {
            // Reset previous highlights visually
            const buttons = [
                document.getElementById('btn-glans'),
                document.getElementById('btn-shaft'),
                document.getElementById('btn-urethra')
            ];
            buttons.forEach(btn => btn.classList.remove('highlight-btn'));

            if (partName && currentShape === 'penis') {
                updateColors(partName, new THREE.Color(0xffff00)); // Yellow highlight
                document.getElementById(`btn-${partName}`).classList.add('highlight-btn');
                updateInfoBox(partName);
            } else {
                updateColors(); // Revert to current color mode
                updateInfoBox('default');
            }
        }

        function updateInfoBox(partName) {
            document.getElementById('anatomy-info').innerHTML = anatomyInfoContent[partName] || anatomyInfoContent['default'];
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // For damping
            // particles.rotation.y += 0.001; // Optional auto-rotation
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>